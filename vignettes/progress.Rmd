---
title: "Introduction to progress bars in cli"
author: "Gábor Csárdi"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_document:
    toc: true
    toc_depth: 2
editor_options:
  markdown:
    wrap: sentence
---

```{r, include = FALSE, cache = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  out.width = "100%",
  cache = TRUE
)
# Turn on ANSI colors
options(
  cli.num_colors = 256L,
  cli_speed = 1
)
asciicast::init_knitr_engine(
  startup = bquote({
    Sys.setenv(CLI_SPEED_TIME = .(getOption("cli_speed")))
    library(cli)
    .GlobalEnv$Sys.sleep <- function(time) {
      base::Sys.sleep(time / .(getOption("cli_speed")))
    }
    set.seed(1)
  }),
  echo = TRUE,
  echo_input = FALSE,
  options = list(
    asciicast_at = NULL,
    asciicast_end_wait = 3 / getOption("cli_speed"),
    asciicast_speed = 1 / getOption("cli_speed"),
    asciicast_cpp11_linkingto = "[[cpp11::linking_to(\"cli\")]]"
  )
)
getOption("asciicast_speed")
```

# Introduction

This document discusses the structure and the simplest uses of the cli
progress bar API. For more advanced usage and the C progress bar API, see
the 'Advanced cli progress bars' article.

From version 3.0.0 cli provides a set of functions to create progress bars.
The main features of the progress bar API are:

* Minimal clutter. It avoids verbose syntax, unless necessary.
* Flexibility from R and C/C++ code. Supports all cli features in proress
  bars: glue interpolation, theming, pluralization, etc.
* Predictably small performance penalty. A very small constant penalty
  per iteration, and a predictable relative penalty per second.

# The R APIs

cli has four sets of R functions to create and manage progress bars:

* `tick_along()` for iteration, this is the best fit for mapping functions,
* `ticking()`, primarily for `while` loops,
* The explicit `cli_progress_bar()`, `cli_progress_update()`,
  `cli_progress_done()` API.
* The `cli_progress_set_status()` and `cli_progress_step()` progress bar
  wrappers for a much simplified display.

## Progress bars for mapping functions: `tick_along()`

To add a progress bar to a call to `lapply()` and other mapping functions,
wrap the sequence you are iterating over into `tick_along()`:

```r
lapply(tick_along(X), fun)
```

`tick_along()` returns a special index vector, that creates and updates a
progress var, as the index elements are accessed.

Note that if you use `tick_along()` then `lapply()` will pass the _indices_
of the elements in `X` to `fun`, instead of the elements themselves.
`tick_along()` expects that the index vector will be used only once,
from beginning to end. To ensure these requirements, it is best if you
never assign the return value of `tick_along()` to a variable.

Here is a complete (albeit artificial), example that uses `tick_along()`:

```{asciicast, tickalong}
f <- function() {
  urls <- rep("https://httpbin.org/delay/0.5", 5)
  dls <- lapply(
    tick_along(urls),
    function(i) {
      download.file(
        urls[i],
        quiet = TRUE,
        file.path(tempdir(), i)
      )
    }
  )
}
f()
```

`tick_along()` uses ALTREP, so it only works from R 3.5.0 and later.
On older R versions it is equivalent to `seq_along()` and it does not
create a progress bar.

### `for` and `repeat` loops

You can also use `tick_along()` in `for` loops, with the additional
complication that if you use `break` then you need to signal the end of
the progress bar explicitly:

```r
for (i in tick_along(seq)) {
  ...
  if (cond) cli_progress_done() && break
  ...
}
```

Alternatively, you can end the progress bar right after loop:

```r
for (i in tick_along(seq)) {
  ...
  if (cond) break
  ...
}
cli_progress_done()
```

## Progress bars for `while` loops: `ticking()`

## The explicit progress bar API

# Customization

```{r, setup}
library(cli)
```

# Status bars

```{asciicast, include = FALSE}
# To test that we shimmed Sys.sleep and the time is speeded up
Sys.sleep
cli:::clienv$speed_time
cli:::clienv$tick_time
```

## Simplified API

```{asciicast}
f <- function() {
  cli_progress_set_status("Task one is running...")
  Sys.sleep(2)

  cli_progress_set_status("Task two is running...")
  Sys.sleep(2)

  step <- 1L
  cli_progress_set_status("Task three is underway: step {step}")
  for (step in 1:5) {
    Sys.sleep(0.5)
    cli_progress_update()
  }
}
f()
```

## Alternative API

```{asciicast}
f <- function(n = 10) {
  cli_alert_info("About to start downloads of {n} file{?s}")
  i <- 0
  cli_progress_step("Got {i}/{n} {qty(i)}file{?s}.")
  for (i in seq_len(n)) {
    Sys.sleep(0.5)
    if (i == 5) cli_alert_info("Already half way!")
    cli_progress_update()
  }
}
f()
```

##  Tight loops

40-60ns per iterations, without printing.

```{asciicast}
f <- function() {
  i <- 0L
  cli_progress_set_status("{.alert-info Read {i} files}")
  for (i in 1:10000) {
    Sys.sleep(5/10000)
    if (should_tick()) cli_progress_update()
  }
  cli_progress_update()
}
f()
```

# Progress bars in R

## Explicit start, update and termination

```{asciicast}
cli_progress_bar(total = 100)
for (i in 1:100) {
  Sys.sleep(5/100)
  cli_progress_update()
}
cli_progress_done()
```

## Tight loops

40-60ns per iterations, without printing.

```{asciicast}
f <- function() {
  cli_progress_bar(total = 10000)
  for (i in 1:10000) {
    Sys.sleep(5/10000)
    if (should_tick()) cli_progress_update(set = i)
  }
}
f()
```

## Unknown total

```{asciicast}
cli_progress_bar()
for (i in 1:100) {
  Sys.sleep(5/100)
  cli_progress_update()
}
cli_progress_done()
```

## Downloads

```{asciicast}
cli_progress_bar(type = "download")
for (i in 1:100) {
  Sys.sleep(5/100)
  cli_progress_update(1024)
}
cli_progress_done()
```

## Custom format

```{asciicast}
f <- function() {
  cli_progress_bar(
    total = 20000,
    format = "Step {step} | {pb_bar} {pb_percent}"
  )
  step <- 1
  for (i in 1:10000) {
    Sys.sleep(2/10000)
    if (should_tick()) cli_progress_update(set = i)
  }
  step <- 2
  for (i in 10001:20000) {
    Sys.sleep(2/10000)
    if (should_tick()) cli_progress_update(set = i)
  }
}
f()
```

## Very custom format

A silly example, but you can use custom functions on progress
bar tokens:

```{asciicast}
f <- function() {
  cli_progress_bar(
    total = 26,
    format = "{pb_spin} This is step {.emph {letters[pb_current]}}. {pb_spin}"
  )
  for (i in 1:26) {
    Sys.sleep(3/26)
    cli_progress_update()
  }
}
f()
```

## While loops with `ticking()`

```{asciicast}
f <- function() {
  i <- 0
  while (ticking(i < 100)) {
    Sys.sleep(3/100)
    i <- i + 1
  }
}
f()
```

## Mapping with `tick_along()`

Needs R 3.5.0.

```{asciicast}
out <- lapply(
  tick_along(letters, "Letters"),
  function(i) Sys.sleep(1)
)
```

# Progress bars in C

```{asciicastcpp11 capi}
#include <cli/progress.h>
SEXP progress_test1() {
  int i;
  SEXP bar = PROTECT(cli_progress_bar(1000));
  for (i = 0; i < 1000; i++) {
    cli_progress_sleep(0, 4 * 1000 * 1000);
    if (SHOULD_TICK) cli_progress_set(bar, i);
  }
  cli_progress_done(bar);
  UNPROTECT(1);
  return Rf_ScalarInteger(i);
}
```

```{asciicast, dependson = -1}
progress_test1()
```
