---
title: "Introduction to progress bars in cli"
author: "Gábor Csárdi"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_document:
    toc: true
    toc_depth: 2
editor_options:
  markdown:
    wrap: sentence
---

```{r, include = FALSE, cache = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  out.width = "100%",
  cache = TRUE
)
# Turn on ANSI colors
options(
  cli.num_colors = 256L
)
asciicast::init_knitr_engine(
  echo = TRUE,
  echo_input = FALSE,
  options = list(
    asciicast_at = NULL,
    asciicast_end_wait = 3,
    asciicast_speed = 1,
    asciicast_cpp11_linkingto = "[[cpp11::linking_to(\"cli\")]]"
  )
)
```

# Introduction

```{asciicast include = FALSE}
set.seed(1)
```

```{asciicast, setup, cache = FALSE, include = FALSE}
library(cli)
options(cli.progress_show_after = 0)
options(cli.progress_clear = FALSE)
```

```r
library(cli)
options(cli.progress_show_after = 0)
options(cli.progress_clear = FALSE)
```

This document discusses the structure and the simplest uses of the cli
progress bar API. For more advanced usage and the C progress bar API, see
the 'Advanced cli progress bars' article.

From version 3.0.0 cli provides a set of functions to create progress bars.
The main goals of the progress bar API are:

* Reduce clutter. Try to avoids verbose syntax, unless necessary.
* Flexibility from R and C/C++ code. Support all cli features in proress
  bars: glue interpolation, theming, pluralization, etc.
* Predictably small performance penalty. A very small constant penalty
  per iteration, and a reasonable penalty per second.

# The R APIs

cli has four sets of R functions to create and manage progress bars:

* The tradional progress bar API: `cli_progress_bar()`,
  `cli_progress_update()`, `cli_progress_done()`.
* The `cli_progress_set_status()` and `cli_progress_step()` progress bar
  wrappers for a much simplified display.
* The `tick_along()` function for iteration.
  This is currently experimental.
* The `ticking()` function, primarily for `while` loops.
  This is currently experimental.

## The traditional progress bar API

Add a progress bar in three steps:

1. Call `cli_progress_bar()` to add create a progress bar.
2. Call `cli_progress_update()` to update it.
3. Call `cli_progress_done()` to terminate it.

For example:

```{asciicast classic-example}
clean <- function() {
  cli_progress_bar("Cleaning data", total = 100)
  for (i in 1:100) {
    Sys.sleep(5/100)
    cli_progress_update()
  }
  cli_progress_done()
}
clean()
```

The traditional API provides full control w.r.t when to create, update and
terminate a progress bar.

## The current progress bar

For conciseness, the progress bar functions refer to the _current progress
bar_ by default. Every function has at most one current progress bar at
any time. The current progress bar of a function is terminated when the
function creates another progress bar or when the function returns, errors
or when it is interrupted.

The current progress bar lets us omit the `cli_progress_done()` call:

```{asciicast current}
clean <- function() {
  cli_progress_bar("Cleaning data #1", total = 100)
  for (i in 1:100) {
    Sys.sleep(3/100)
    cli_progress_update()
  }

  cli_progress_bar("Cleaning data #2", total = 100)
  for (i in 1:100) {
    Sys.sleep(3/100)
    cli_progress_update()
  }
}
clean()
```

## Unknown total number of units

In some cases the total number of progress units is unknown, so simply
omit them from `cli_progress_bar()` (or set them to `NA`):

```{asciicast unknown-total}
walk_dirs <- function() {
  cli_progress_bar("Walking directories")
  cli_progress_update(force = TRUE)
  while (TRUE) {
    if (runif(1) < 0.01) break
    cli_progress_update()
  }
}
walk_dirs()
```

## Quick progress bars

By default, progress bars that are terminated within two seconds after
they were created are not shown. The end user can configure this limit
with the `cli.progress_show_after` global option.

In this document we set the limit to zero, so progress bars are shown at
their first update.

## Downloads

TODO

## Progress bars for mapping functions: `tick_along()`

Note that this API is currently experimental.

To add a progress bar to a call to `lapply()` and other mapping functions,
wrap the sequence you are iterating over into `tick_along()`:

```r
lapply(tick_along(X), fun)
```

`tick_along()` returns a special index vector, that creates and updates a
progress var, as the index elements are accessed.

Note that if you use `tick_along()` then `lapply()` will pass the _indices_
of the elements in `X` to `fun`, instead of the elements themselves.
`tick_along()` expects that the index vector will be used only once,
from beginning to end. To ensure these requirements, it is best if you
never assign the return value of `tick_along()` to a variable.

Here is a complete (albeit artificial), example that uses `tick_along()`:

```{asciicast, tickalong}
f <- function() {
  urls <- rep("https://httpbin.org/delay/0.5", 5)
  dls <- lapply(
    tick_along(urls),
    function(i) {
      download.file(
        urls[i],
        quiet = TRUE,
        file.path(tempdir(), i)
      )
    }
  )
}
f()
```

`tick_along()` uses ALTREP, so it only works from R 3.5.0 and later.
On older R versions it is equivalent to `seq_along()` and it does not
create a progress bar.

### `for` and `repeat` loops

You can also use `tick_along()` in `for` loops, with the additional
complication that if you use `break` then you need to signal the end of
the progress bar explicitly:

```r
for (i in tick_along(seq)) {
  ...
  if (cond) cli_progress_done() && break
  ...
}
```

Alternatively, you can end the progress bar right after loop:

```r
for (i in tick_along(seq)) {
  ...
  if (cond) break
  ...
}
cli_progress_done()
```

## Progress bars for `while` loops: `ticking()`

# Customization

# Status bars

```{asciicast, include = FALSE}
# To test that we shimmed Sys.sleep and the time is speeded up
Sys.sleep
cli:::clienv$speed_time
cli:::clienv$tick_time
```

## Simplified API

```{asciicast}
f <- function() {
  cli_progress_set_status("Task one is running...")
  Sys.sleep(2)

  cli_progress_set_status("Task two is running...")
  Sys.sleep(2)

  step <- 1L
  cli_progress_set_status("Task three is underway: step {step}")
  for (step in 1:5) {
    Sys.sleep(0.5)
    cli_progress_update()
  }
}
f()
```

## Alternative API

```{asciicast}
f <- function(n = 10) {
  cli_alert_info("About to start downloads of {n} file{?s}")
  i <- 0
  cli_progress_step("Got {i}/{n} {qty(i)}file{?s}.")
  for (i in seq_len(n)) {
    Sys.sleep(0.5)
    if (i == 5) cli_alert_info("Already half way!")
    cli_progress_update()
  }
}
f()
```

##  Tight loops

40-60ns per iterations, without printing.

```{asciicast}
f <- function() {
  i <- 0L
  cli_progress_set_status("{.alert-info Read {i} files}")
  for (i in 1:10000) {
    Sys.sleep(5/10000)
    if (should_tick) cli_progress_update()
  }
  cli_progress_update()
}
f()
```

# Progress bars in R

## Explicit start, update and termination

```{asciicast}
cli_progress_bar(total = 100)
for (i in 1:100) {
  Sys.sleep(5/100)
  cli_progress_update()
}
cli_progress_done()
```

## Tight loops

40-60ns per iterations, without printing.

```{asciicast}
f <- function() {
  cli_progress_bar(total = 10000)
  for (i in 1:10000) {
    Sys.sleep(5/10000)
    if (should_tick) cli_progress_update(set = i)
  }
}
f()
```

## Unknown total

```{asciicast}
cli_progress_bar()
for (i in 1:100) {
  Sys.sleep(5/100)
  cli_progress_update()
}
cli_progress_done()
```

## Downloads

```{asciicast}
cli_progress_bar(type = "download")
for (i in 1:100) {
  Sys.sleep(5/100)
  cli_progress_update(1024)
}
cli_progress_done()
```

## Custom format

```{asciicast}
f <- function() {
  cli_progress_bar(
    total = 20000,
    format = "Step {step} | {pb_bar} {pb_percent}"
  )
  step <- 1
  for (i in 1:10000) {
    Sys.sleep(2/10000)
    if (should_tick) cli_progress_update(set = i)
  }
  step <- 2
  for (i in 10001:20000) {
    Sys.sleep(2/10000)
    if (should_tick) cli_progress_update(set = i)
  }
}
f()
```

## Very custom format

A silly example, but you can use custom functions on progress
bar tokens:

```{asciicast}
f <- function() {
  cli_progress_bar(
    total = 26,
    format = "{pb_spin} This is step {.emph {letters[pb_current]}}. {pb_spin}"
  )
  for (i in 1:26) {
    Sys.sleep(3/26)
    cli_progress_update()
  }
}
f()
```

## While loops with `ticking()`

```{asciicast}
f <- function() {
  i <- 0
  while (ticking(i < 100)) {
    Sys.sleep(3/100)
    i <- i + 1
  }
}
f()
```

## Mapping with `tick_along()`

Needs R 3.5.0.

```{asciicast}
out <- lapply(
  tick_along(letters, "Letters"),
  function(i) Sys.sleep(1)
)
```

# Progress bars in C

```{asciicastcpp11 capi}
#include <cli/progress.h>
SEXP progress_test1() {
  int i;
  SEXP bar = PROTECT(cli_progress_bar(1000));
  for (i = 0; i < 1000; i++) {
    cli_progress_sleep(0, 4 * 1000 * 1000);
    if (SHOULD_TICK) cli_progress_set(bar, i);
  }
  cli_progress_done(bar);
  UNPROTECT(1);
  return Rf_ScalarInteger(i);
}
```

```{asciicast, dependson = -1}
progress_test1()
```
